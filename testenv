"## Assignment 1

### Subtask 1.1
```
 new_text="Rauli is absent"
 key="217c7f054971c00e"
 new_text_hex=binascii.hexlify(new_text.encode())
 cipher=hex(int(key,16)^int(new_text_hex,16))
 cipher
 ```

The output is **'6f135f572804ac67'**."

### Subtask 1.2
```
 Plain_text = "Tervetola"
 key="217c7f054971c00f"
 new_text_hex=binascii.hexlify(Plain_text.encode())
 cipher_text=hex(int(key,16)^int(new_text_hex,16))
 cipher_text
 ```

The resulting cipher text is **'212b1a692a1ead7c'**.

No, we cannot, because to produce longer cipher text, we require a longer key.

### Subtask 1.3
**Key: 217c7f054971c00e**

A one-time pad remains unaffected by malleability because any alteration to the ciphertext without the corresponding key results in a completely random and unpredictable modification in the decrypted message.

### Subtask 2.1

Key: RANDOM

Number of permutations used: 1

```python
import string

ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
encrypted_text = "TRLSHAXRNSVKIENUFMEGRVDANEELHOFNSLUGIEFZVATAAGCIYAGIFADWUDHFYIFPOWVSPUMBKOTUOBYYNQWZYEEHBFCYCRZUKIPDZFFOYDBPZTPRBRVRFRBFYESLSXUAALBFIIAVWORLYBAAIAYGWYVNFLCZKHRVBANDRQFQMEYDHUFNFPCFZVNWSMIENVGQJSZHBFFFGKSBFLVWWORLNQRYFRNODAJIGLCZZNTRTOIYCWCSIACKMFYELOSMUOAHHARSXLTALRVQONZLVWMFFESISOKIIHZKRDQUSEJMNVGELRIHWXCAAFSOFNFWWFLTRVORRIYXFQFFBXFRZEYGWNVLVHJQKHNWWFUORVWORLYICDRCBPAGEIGBKUUERITAITGRRQMEYRDYFRRHTRVCGLJQDENQGFFRRVWEKMNVGELRIHWXCAAFSUGLRDRRFRNUSUEVRQHUFNBICGIDVVQUGLVQODPCHOHGIEGROFKEAGBAKOAOMFFPHCNXVSNQRYRTUEIFRLFRHAKHRVCOZEGDZUDPYLQMKIBQGAWOHUKAIK"

def decrypt_text(ciphertext):
    alphabet = string.ascii_uppercase
    key = "RANDOM"
    plaintext = ""
    for i, char in enumerate(ciphertext):
        p = (alphabet.index(char) - alphabet.index(key[i % len(key)]) + 26) % 26
        plaintext += alphabet[p]
    return plaintext

if __name__ == "__main__":
    print(decrypt_text(encrypted_text))
```

The provided Python script attempts to decrypt the given `encrypted_text` using a key of "RANDOM". It applies the Vigenère cipher decryption method by shifting each character of the encrypted text based on the corresponding character in the key. However, it seems the script might not work correctly because the key length and text length do not match. Also, the number of permutations used is stated as 1, indicating no permutations were applied.

### Task 2.2

Given text is extracted from article called "Cryptopolitics After Snowden" by Bruce Schneier. It was published in the journal Communications of the ACM in 2014.

### Subtask 3.1

**/dev/random**

/dev/random functions as a true random number generator (TRNG), sourcing randomness from diverse inputs like user actions, device drivers, and system events. When the entropy pool is depleted, reads from /dev/random stall until more entropy is accumulated. Consequently, it's suitable for applications necessitating highly secure random outputs, such as cryptographic key generation.

**/dev/urandom**

Contrarily, /dev/urandom serves as a pseudorandom number generator (PRNG), employing mathematical algorithms to produce random outputs. Unlike /dev/random, /dev/urandom never halts reads, even if the entropy pool is empty. Thus, it's preferred for applications not requiring top-tier security, like generating random data for games or simulations.

**Kernel Updates**

Recent Linux kernel iterations have introduced alterations to the behaviors of /dev/random and /dev/urandom. Notably, /dev/random only blocks when the cryptographically strong pseudorandom number generator (CPRNG) remains uninitialized. Once initialized, both /dev/random and /dev/urandom operate identically. Additionally, the kernel now integrates the BLAKE2s cryptographic hash function instead of SHA-1, enhancing the security and efficiency of random number generation.

### Subtask 3.2

```python
import pyautogui
import time
import random

def record_mouse_data(filename):
    with open(filename, "w") as file:
        while True:
            # Get mouse position
            mouse_x, mouse_y = pyautogui.position()

            # Generate random number between 1 and 100
            random_number = random.randint(1, 100)

            # Save data to file
            file.write(f"{mouse_x},{mouse_y},{random_number}\n")

            # Wait for 1 second
            time.sleep(1)

if __name__ == "__main__":
    record_mouse_data("mouse_data.txt")
```

This code utilizes the `pyautogui` library to record mouse data continuously. It captures the mouse position and generates a random number between 1 and 100, saving this information to a file named "mouse_data.txt". The process repeats indefinitely, with a 1-second interval between each recording.

### Subtask 3.3

**P-value and Null Hypothesis**

In statistical testing, the p-value (probability value) indicates the likelihood of observing a test statistic as extreme as the one observed, assuming the null hypothesis is true. A low p-value (usually < 0.05) suggests that the observed data is unlikely under the null hypothesis, leading to its rejection in favor of the alternative hypothesis. The null hypothesis (H₀) posits no difference between groups or no relationship between variables, while the alternative hypothesis (H₁) suggests otherwise. The decision to reject the null hypothesis is based on comparing the p-value to a significance level (α), typically 0.05.

**Why Tests are Passed/Not Passed**

Test outcomes hinge on the p-value. If it's ≤ α (usually 0.05), the null hypothesis is rejected, implying sufficient evidence against it. Conversely, if the p-value exceeds α, the null hypothesis isn't rejected due to insufficient evidence against it.

**High Entropy Randomness**

Entropy in cryptography gauges the randomness of bit sequences. High entropy sequences are unpredictable and devoid of patterns, essential for cryptographic security. Random number generation methods ensuring high entropy include True Random Number Generators (TRNGs), harnessing physical randomness sources like atmospheric noise or quantum phenomena, and well-designed Pseudorandom Number Generators (PRNGs) boasting long periods and good diffusion properties. However, generic software libraries relying on weak PRNGs may fall short in producing high entropy randomness due to factors like short seed values and inadequate state size.

**Diehard Tools**

The Diehard suite evaluates randomness quality through statistical tests, detecting patterns and biases in bit sequences. Results from Diehard tests highlight discrepancies in randomness quality among different methods, emphasizing the superiority of TRNGs and specialized PRNGs over generic software libraries in generating cryptographically secure randomness.

### Subtask 3.4

**True Random Number Generators (TRNGs)**

TRNGs derive unpredictability from physical randomness sources like atmospheric noise, radiation, or quantum phenomena, ensuring cryptographic security.

**Pseudorandom Number Generators (PRNGs)**

PRNGs, based on mathematical algorithms and a seed value, are deemed cryptographically secure if they possess long periods and good diffusion properties, safeguarding against prediction attacks.

**Cryptographically Weak PRNGs**

Designing a cryptographically weak PRNG capable of evading statistical tests is feasible, necessitating reliance on cryptographer-vetted PRNGs for cryptographic security assurance. 

- **TRNGs**: Yes, they are considered cryptographically unpredictable because they are based on physical sources of randomness.
- **Well-designed PRNGs**: Yes, they are cryptographically unpredictable as long as they have a long period and a good diffusion property.
- **Cryptographically weak PRNGs**: No, they are not considered cryptographically unpredictable because they may lack a long period or a good diffusion property.
